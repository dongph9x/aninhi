import { 
    ButtonInteraction, 
    StringSelectMenuInteraction, 
    EmbedBuilder,
    ActionRowBuilder,
    ButtonBuilder,
    ButtonStyle
} from "discord.js";
import { BattleFishInventoryService } from "@/utils/battle-fish-inventory";
import { FishBattleService } from "@/utils/fish-battle";
import { BattleFishUI } from "./BattleFishUI";

export class BattleFishHandler {
    private static battleFishMessages = new Map<string, {
        userId: string;
        guildId: string;
        inventory: any;
        eligibleFish: any[];
        selectedFishId?: string;
        currentOpponent?: any;
        currentUserFish?: any;
    }>();

    static async handleInteraction(interaction: ButtonInteraction | StringSelectMenuInteraction) {
        const customId = interaction.customId;
        const messageId = interaction.message.id;
        const userId = interaction.user.id;
        const guildId = interaction.guildId!;

        console.log(`üîç [DEBUG] handleInteraction called:`);
        console.log(`  - customId: ${customId}`);
        console.log(`  - messageId: ${messageId}`);
        console.log(`  - userId: ${userId}`);
        console.log(`  - guildId: ${guildId}`);
        console.log(`  - Cache size: ${this.battleFishMessages.size}`);

        // L·∫•y th√¥ng tin message t·ª´ cache
        let messageData = this.battleFishMessages.get(messageId);
        
        // Fallback: T√¨m data b·∫±ng user ID v√† guild ID n·∫øu kh√¥ng t√¨m th·∫•y b·∫±ng message ID
        if (!messageData) {
            console.log(`  - ‚ùå No messageData found for messageId: ${messageId}`);
            console.log(`  - Available keys: ${Array.from(this.battleFishMessages.keys()).join(', ')}`);
            
            // T√¨m data b·∫±ng user ID v√† guild ID
            for (const [key, data] of this.battleFishMessages.entries()) {
                if (data.userId === userId && data.guildId === guildId) {
                    messageData = data;
                    console.log(`  - ‚úÖ Found messageData using fallback key: ${key}`);
                    break;
                }
            }
        }
        
        console.log(`  - Found messageData: ${!!messageData}`);
        
        if (!messageData) {
            console.log(`  - ‚ùå No messageData found for messageId: ${messageId}`);
            console.log(`  - Available keys: ${Array.from(this.battleFishMessages.keys()).join(', ')}`);
            return interaction.reply({ 
                content: '‚ùå Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu ho·∫∑c b·∫°n kh√¥ng ph·∫£i ch·ªß s·ªü h·ªØu!', 
                ephemeral: true 
            });
        }

        if (messageData.userId !== userId) {
            console.log(`  - ‚ùå User ID mismatch: ${messageData.userId} !== ${userId}`);
            return interaction.reply({ 
                content: '‚ùå Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu ho·∫∑c b·∫°n kh√¥ng ph·∫£i ch·ªß s·ªü h·ªØu!', 
                ephemeral: true 
            });
        }

        console.log(`  - ‚úÖ MessageData found and validated`);
        console.log(`  - Current User Fish: ${messageData.currentUserFish?.name || 'undefined'}`);
        console.log(`  - Current Opponent: ${messageData.currentOpponent?.name || 'undefined'}`);

        try {
            if (interaction.isStringSelectMenu()) {
                await this.handleSelectMenu(interaction, messageData);
            } else if (interaction.isButton()) {
                await this.handleButton(interaction, messageData);
            }
        } catch (error) {
            console.error('Error handling battle fish interaction:', error);
            await interaction.reply({ 
                content: '‚ùå C√≥ l·ªói x·∫£y ra khi x·ª≠ l√Ω t∆∞∆°ng t√°c!', 
                ephemeral: true 
            });
        }
    }

    private static async handleSelectMenu(interaction: StringSelectMenuInteraction, messageData: any) {
        const selectedValue = interaction.values[0];
        
        if (selectedValue === 'no_fish') {
            await interaction.reply({ 
                content: '‚ùå Kh√¥ng c√≥ c√° n√†o ƒë·ªÉ ch·ªçn! H√£y t·∫°o c√° th·∫ø h·ªá 2+ v√† nu√¥i l√™n level 10.', 
                ephemeral: true 
            });
            return;
        }

        // C·∫≠p nh·∫≠t selected fish ID
        messageData.selectedFishId = selectedValue;

        // L√†m m·ªõi UI
        await this.refreshUI(interaction, messageData);
        await interaction.reply({ 
            content: `‚úÖ ƒê√£ ch·ªçn c√°! S·ª≠ d·ª•ng c√°c n√∫t b√™n d∆∞·ªõi ƒë·ªÉ thao t√°c.`, 
            ephemeral: true 
        });
    }

    private static async handleButton(interaction: ButtonInteraction, messageData: any) {
        const customId = interaction.customId;

        switch (customId) {
            case 'battle_fish_add':
                await this.handleAddFish(interaction, messageData);
                break;
            case 'battle_fish_remove':
                await this.handleRemoveFish(interaction, messageData);
                break;
            case 'battle_fish_fight':
                await this.handleFindOpponent(interaction, messageData);
                break;
            case 'battle_fish_stats':
                await this.handleShowStats(interaction, messageData);
                break;
            case 'battle_fish_history':
                await this.handleShowHistory(interaction, messageData);
                break;
            case 'battle_fish_leaderboard':
                await this.handleShowLeaderboard(interaction, messageData);
                break;
            case 'battle_fish_refresh':
                await this.handleRefresh(interaction, messageData);
                break;
            case 'battle_fish_confirm_fight':
                await this.handleConfirmFight(interaction, messageData);
                break;
            case 'battle_fish_help':
                await this.handleShowHelp(interaction, messageData);
                break;
            default:
                await interaction.reply({ 
                    content: '‚ùå H√†nh ƒë·ªông kh√¥ng h·ª£p l·ªá!', 
                    ephemeral: true 
                });
        }
    }

    private static async handleAddFish(interaction: ButtonInteraction, messageData: any) {
        const actualFishId = messageData.selectedFishId?.replace('eligible_', '');
        
        if (!actualFishId) {
            await interaction.reply({ 
                content: '‚ùå Vui l√≤ng ch·ªçn c√° ƒë·ªÉ th√™m!', 
                ephemeral: true 
            });
            return;
        }

        const result = await BattleFishInventoryService.addFishToBattleInventory(
            messageData.userId, 
            messageData.guildId, 
            actualFishId
        );

        if (result.success) {
            // C·∫≠p nh·∫≠t d·ªØ li·ªáu
            await this.updateMessageData(messageData);
            
            // L√†m m·ªõi UI
            await this.refreshUI(interaction, messageData);
            
            await interaction.reply({ 
                content: `‚úÖ ƒê√£ th√™m **${result.inventoryItem.fish.name}** v√†o t√∫i ƒë·∫•u!`, 
                ephemeral: true 
            });
        } else {
            await interaction.reply({ 
                content: `‚ùå Kh√¥ng th·ªÉ th√™m c√°: ${result.error}`, 
                ephemeral: true 
            });
        }
    }

    private static async handleRemoveFish(interaction: ButtonInteraction, messageData: any) {
        const actualFishId = messageData.selectedFishId?.replace('battle_', '');
        
        if (!actualFishId) {
            await interaction.reply({ 
                content: '‚ùå Vui l√≤ng ch·ªçn c√° trong t√∫i ƒë·∫•u ƒë·ªÉ x√≥a!', 
                ephemeral: true 
            });
            return;
        }

        const result = await BattleFishInventoryService.removeFishFromBattleInventory(
            messageData.userId, 
            messageData.guildId, 
            actualFishId
        );

        if (result.success) {
            // C·∫≠p nh·∫≠t d·ªØ li·ªáu
            await this.updateMessageData(messageData);
            
            // Reset selected fish
            messageData.selectedFishId = undefined;
            
            // L√†m m·ªõi UI
            await this.refreshUI(interaction, messageData);
            
            await interaction.reply({ 
                content: '‚úÖ ƒê√£ x√≥a c√° kh·ªèi t√∫i ƒë·∫•u!', 
                ephemeral: true 
            });
        } else {
            await interaction.reply({ 
                content: `‚ùå Kh√¥ng th·ªÉ x√≥a c√°: ${result.error}`, 
                ephemeral: true 
            });
        }
    }

    private static async handleFindOpponent(interaction: ButtonInteraction, messageData: any) {
        console.log(`üîç [DEBUG] handleFindOpponent called:`);
        console.log(`  - messageId: ${interaction.message.id}`);
        console.log(`  - userId: ${messageData.userId}`);
        console.log(`  - guildId: ${messageData.guildId}`);
        console.log(`  - inventory items: ${messageData.inventory?.items?.length || 0}`);
        
        if (messageData.inventory.items.length === 0) {
            console.log(`  - ‚ùå No fish in battle inventory`);
            await interaction.reply({ 
                content: '‚ùå Kh√¥ng c√≥ c√° n√†o trong t√∫i ƒë·∫•u!', 
                ephemeral: true 
            });
            return;
        }

        // Ch·ªçn c√° ƒë·∫ßu ti√™n trong t√∫i ƒë·∫•u
        const selectedFish = messageData.inventory.items[0].fish;
        console.log(`  - Selected fish: ${selectedFish.name} (ID: ${selectedFish.id})`);
        
        const opponentResult = await FishBattleService.findRandomOpponent(
            messageData.userId, 
            messageData.guildId, 
            selectedFish.id
        );

        if (!opponentResult.success) {
            console.log(`  - ‚ùå No opponent found: ${opponentResult.error}`);
            await interaction.reply({ 
                content: `‚ùå Kh√¥ng t√¨m th·∫•y ƒë·ªëi th·ªß: ${opponentResult.error}`, 
                ephemeral: true 
            });
            return;
        }

        console.log(`  - ‚úÖ Found opponent: ${opponentResult.opponent.name} (ID: ${opponentResult.opponent.id})`);

        // L∆∞u th√¥ng tin ƒë·ªëi th·ªß ƒë·ªÉ s·ª≠ d·ª•ng sau
        messageData.currentOpponent = opponentResult.opponent;
        messageData.currentUserFish = selectedFish;

        // T·∫°o embed th√¥ng tin tr∆∞·ªõc khi ƒë·∫•u
        const stats = selectedFish.stats || {};
        const opponentStats = opponentResult.opponent?.stats || {};
        const userPower = this.calculatePower(selectedFish);
        const opponentPower = this.calculatePower(opponentResult.opponent || {});

        const embed = new EmbedBuilder()
            .setTitle('‚öîÔ∏è T√¨m Th·∫•y ƒê·ªëi Th·ªß!')
            .setColor('#FFD700')
            .addFields(
                { name: 'üêü C√° c·ªßa b·∫°n', value: `${selectedFish.name} (Lv.${selectedFish.level})`, inline: true },
                { name: 'üêü ƒê·ªëi th·ªß', value: `${opponentResult.opponent.name} (Lv.${opponentResult.opponent.level})`, inline: true },
                { name: 'üí™ S·ª©c m·∫°nh', value: `${userPower} vs ${opponentPower}`, inline: true },
                { name: 'üìä Stats c·ªßa b·∫°n', value: `üí™${stats.strength || 0} üèÉ${stats.agility || 0} üß†${stats.intelligence || 0} üõ°Ô∏è${stats.defense || 0} üçÄ${stats.luck || 0}`, inline: false },
                { name: 'üìä Stats ƒë·ªëi th·ªß', value: `üí™${opponentStats.strength || 0} üèÉ${opponentStats.agility || 0} üß†${opponentStats.intelligence || 0} üõ°Ô∏è${opponentStats.defense || 0} üçÄ${opponentStats.luck || 0}`, inline: false }
            )
            .setDescription('React v·ªõi ‚öîÔ∏è ƒë·ªÉ b·∫Øt ƒë·∫ßu ƒë·∫•u!')
            .setTimestamp();

        const battleButton = new ActionRowBuilder<ButtonBuilder>()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('battle_fish_confirm_fight')
                    .setLabel('‚öîÔ∏è B·∫Øt ƒê·∫ßu ƒê·∫•u')
                    .setStyle(ButtonStyle.Danger)
            );

        const reply = await interaction.reply({ 
            embeds: [embed], 
            components: [battleButton],
            ephemeral: true 
        });

        // L∆∞u messageData cho reply m·ªõi
        this.battleFishMessages.set(reply.id, messageData);
        
        // Fallback: L∆∞u data b·∫±ng c√°ch kh√°c n·∫øu reply.id kh√¥ng ho·∫°t ƒë·ªông
        const fallbackKey = `battle_${messageData.userId}_${messageData.guildId}_${Date.now()}`;
        this.battleFishMessages.set(fallbackKey, messageData);
        
        console.log(`üîç [DEBUG] handleFindOpponent completed:`);
        console.log(`  - Original messageId: ${interaction.message.id}`);
        console.log(`  - Reply messageId: ${reply.id}`);
        console.log(`  - Fallback key: ${fallbackKey}`);
        console.log(`  - Cache size after save: ${this.battleFishMessages.size}`);
        console.log(`  - Available keys: ${Array.from(this.battleFishMessages.keys()).join(', ')}`);
        console.log(`  - Current User Fish saved: ${messageData.currentUserFish?.name || 'undefined'}`);
        console.log(`  - Current Opponent saved: ${messageData.currentOpponent?.name || 'undefined'}`);
    }

    private static async handleShowStats(interaction: ButtonInteraction, messageData: any) {
        const stats = await FishBattleService.getBattleStats(messageData.userId, messageData.guildId);

        const embed = new EmbedBuilder()
            .setTitle('üìä Th·ªëng K√™ ƒê·∫•u C√°')
            .setColor('#4ECDC4')
            .addFields(
                { name: '‚öîÔ∏è T·ªïng s·ªë tr·∫≠n', value: stats.totalBattles.toString(), inline: true },
                { name: 'üèÜ Chi·∫øn th·∫Øng', value: stats.wins.toString(), inline: true },
                { name: 'üíÄ Th·∫•t b·∫°i', value: stats.losses.toString(), inline: true },
                { name: 'üìà T·ª∑ l·ªá th·∫Øng', value: `${stats.winRate}%`, inline: true },
                { name: 'üí∞ T·ªïng thu nh·∫≠p', value: stats.totalEarnings.toLocaleString(), inline: true }
            )
            .setTimestamp();

        await interaction.reply({ embeds: [embed], ephemeral: true });
    }

    private static async handleShowHistory(interaction: ButtonInteraction, messageData: any) {
        const battles = await FishBattleService.getRecentBattles(messageData.userId, messageData.guildId, 5);

        if (battles.length === 0) {
            const embed = new EmbedBuilder()
                .setTitle('üìú L·ªãch S·ª≠ ƒê·∫•u C√°')
                .setColor('#FFA500')
                .setDescription('B·∫°n ch∆∞a c√≥ tr·∫≠n ƒë·∫•u n√†o!')
                .setTimestamp();

            await interaction.reply({ embeds: [embed], ephemeral: true });
            return;
        }

        const embed = new EmbedBuilder()
            .setTitle('üìú L·ªãch S·ª≠ ƒê·∫•u C√° G·∫ßn ƒê√¢y')
            .setColor('#4ECDC4')
            .setTimestamp();

        battles.forEach((battle: any, index: number) => {
            const result = battle.userWon ? 'üèÜ' : 'üíÄ';
            const userFishName = battle.userFish?.name || 'Unknown Fish';
            const opponentFishName = battle.opponentFish?.name || 'Unknown Opponent';
            const reward = battle.reward.toLocaleString();
            const date = new Date(battle.battledAt).toLocaleDateString('vi-VN');

            embed.addFields({
                name: `${result} Tr·∫≠n ${index + 1} (${date})`,
                value: `üêü ${userFishName} vs ${opponentFishName} | üêü ${reward} FishCoin | üí™ ${battle.userPower} vs ${battle.opponentPower}`,
                inline: false
            });
        });

        await interaction.reply({ embeds: [embed], ephemeral: true });
    }

    private static async handleShowLeaderboard(interaction: ButtonInteraction, messageData: any) {
        const leaderboard = await FishBattleService.getBattleLeaderboard(messageData.guildId, 10);

        if (leaderboard.length === 0) {
            const embed = new EmbedBuilder()
                .setTitle('üèÜ B·∫£ng X·∫øp H·∫°ng ƒê·∫•u C√°')
                .setColor('#FFA500')
                .setDescription('Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·∫•u c√° n√†o!')
                .setTimestamp();

            await interaction.reply({ embeds: [embed], ephemeral: true });
            return;
        }

        const embed = new EmbedBuilder()
            .setTitle('üèÜ B·∫£ng X·∫øp H·∫°ng ƒê·∫•u C√°')
            .setColor('#FFD700')
            .setTimestamp();

        leaderboard.forEach((user: any, index: number) => {
            const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
            const winRate = user.totalBattles > 0 ? Math.round((user.wins / user.totalBattles) * 100) : 0;
            
            // Chuy·ªÉn ƒë·ªïi BigInt th√†nh Number ƒë·ªÉ tr√°nh l·ªói
            const totalEarnings = typeof user.totalEarnings === 'bigint' 
                ? Number(user.totalEarnings) 
                : user.totalEarnings;

            embed.addFields({
                name: `${medal} <@${user.userId}>`,
                value: `üèÜ ${user.wins}W/${user.totalBattles}L (${winRate}%) | üêü ${totalEarnings.toLocaleString()} FishCoin`,
                inline: false
            });
        });

        await interaction.reply({ embeds: [embed], ephemeral: true });
    }

    private static async handleRefresh(interaction: ButtonInteraction, messageData: any) {
        // C·∫≠p nh·∫≠t d·ªØ li·ªáu
        await this.updateMessageData(messageData);
        
        // L√†m m·ªõi UI
        await this.refreshUI(interaction, messageData);
        
        await interaction.reply({ 
            content: '‚úÖ ƒê√£ l√†m m·ªõi d·ªØ li·ªáu!', 
            ephemeral: true 
        });
    }

    private static async handleConfirmFight(interaction: ButtonInteraction, messageData: any) {
        // Ki·ªÉm tra xem c√≥ th√¥ng tin ƒë·ªëi th·ªß ƒë√£ t√¨m th·∫•y kh√¥ng
        if (!messageData.currentOpponent || !messageData.currentUserFish) {
            await interaction.reply({ 
                content: '‚ùå Vui l√≤ng t√¨m ƒë·ªëi th·ªß tr∆∞·ªõc khi ƒë·∫•u!', 
                ephemeral: true 
            });
            return;
        }

        const selectedFish = messageData.currentUserFish;
        const opponent = messageData.currentOpponent;

        // B·∫Øt ƒë·∫ßu animation
        await interaction.deferReply({ ephemeral: true });

        // Animation frames
        const animationFrames = [
            '‚öîÔ∏è **B·∫Øt ƒë·∫ßu chi·∫øn ƒë·∫•u!** ‚öîÔ∏è',
            'üêü **${selectedFish.name}** vs **${opponent.name}** üêü',
            'üí• **ƒêang ƒë·∫•u...** üí•',
            '‚ö° **Chi·∫øn ƒë·∫•u gay c·∫•n!** ‚ö°',
            'üî• **K·∫øt qu·∫£ s·∫Øp c√≥!** üî•'
        ];

        const animationEmbed = new EmbedBuilder()
            .setTitle('‚öîÔ∏è Chi·∫øn ƒê·∫•u ƒêang Di·ªÖn Ra...')
            .setColor('#FF6B6B')
            .setDescription(animationFrames[0])
            .setTimestamp();

        const animationMessage = await interaction.editReply({ 
            embeds: [animationEmbed]
        });

        // Ch·∫°y animation trong 3 gi√¢y
        for (let i = 1; i < animationFrames.length; i++) {
            await new Promise(resolve => setTimeout(resolve, 600)); // 600ms m·ªói frame
            
            const currentFrame = animationFrames[i]
                .replace('${selectedFish.name}', selectedFish.name)
                .replace('${opponent.name}', opponent.name);
            
            animationEmbed.setDescription(currentFrame);
            await interaction.editReply({ embeds: [animationEmbed] });
        }

        // Th·ª±c hi·ªán battle
        const battleResult = await FishBattleService.battleFish(
            messageData.userId, 
            messageData.guildId, 
            selectedFish.id, 
            opponent.id
        );

        if ('success' in battleResult && !battleResult.success) {
            const errorEmbed = new EmbedBuilder()
                .setTitle('‚ùå L·ªói ƒë·∫•u c√°!')
                .setColor('#FF0000')
                .setDescription(battleResult.error)
                .setTimestamp();

            await interaction.editReply({ embeds: [errorEmbed] });
            return;
        }

        const result = battleResult as any;
        const isUserWinner = result.winner.id === selectedFish.id;
        const reward = isUserWinner ? result.rewards.winner : result.rewards.loser;

        // Hi·ªÉn th·ªã k·∫øt qu·∫£
        const battleEmbed = new EmbedBuilder()
            .setTitle(isUserWinner ? 'üèÜ Chi·∫øn Th·∫Øng!' : 'üíÄ Th·∫•t B·∫°i!')
            .setColor(isUserWinner ? '#00FF00' : '#FF0000')
            .addFields(
                { name: 'üêü Ng∆∞·ªùi th·∫Øng', value: result.winner.name, inline: true },
                { name: 'üêü Ng∆∞·ªùi thua', value: result.loser.name, inline: true },
                { name: 'üêü Ph·∫ßn th∆∞·ªüng', value: `${reward.toLocaleString()} FishCoin`, inline: true },
                { name: 'üí™ S·ª©c m·∫°nh', value: `${result.winnerPower} vs ${result.loserPower}`, inline: true }
            )
            .setDescription(result.battleLog.join('\n'))
            .setTimestamp();

        await interaction.editReply({ embeds: [battleEmbed] });
    }

    private static async handleShowHelp(interaction: ButtonInteraction, messageData: any) {
        const embed = new EmbedBuilder()
            .setTitle('‚ùì H∆∞·ªõng D·∫´n H·ªá Th·ªëng ƒê·∫•u C√°')
            .setColor('#FF6B6B')
            .setDescription('H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng h·ªá th·ªëng ƒë·∫•u c√°!')
            .addFields(
                { name: 'üéØ C√°ch s·ª≠ d·ª•ng', value: '1. **Ch·ªçn c√°** t·ª´ dropdown\n2. **Th√™m c√°** v√†o t√∫i ƒë·∫•u\n3. **T√¨m ƒë·ªëi th·ªß** ƒë·ªÉ ƒë·∫•u\n4. **X√≥a c√°** kh·ªèi t√∫i ƒë·∫•u n·∫øu c·∫ßn', inline: false },
                { name: 'üìä Thu·ªôc t√≠nh c√°', value: 'üí™ S·ª©c m·∫°nh | üèÉ Th·ªÉ l·ª±c | üß† Tr√≠ tu·ªá | üõ°Ô∏è Ph√≤ng th·ªß | üçÄ May m·∫Øn', inline: false },
                { name: 'üí∞ Ph·∫ßn th∆∞·ªüng', value: 'Ng∆∞·ªùi th·∫Øng: 150% s·ª©c m·∫°nh t·ªïng\nNg∆∞·ªùi thua: 30% s·ª©c m·∫°nh t·ªïng', inline: false },
                { name: '‚ö†Ô∏è ƒêi·ªÅu ki·ªán c√° ƒë·∫•u', value: '‚Ä¢ Ph·∫£i l√† c√° th·∫ø h·ªá 2 tr·ªü l√™n\n‚Ä¢ Ph·∫£i l√† c√° tr∆∞·ªüng th√†nh (level 10)\n‚Ä¢ T√∫i ƒë·∫•u t·ªëi ƒëa 5 c√°', inline: false }
            )
            .setTimestamp();

        await interaction.reply({ embeds: [embed], ephemeral: true });
    }

    private static async updateMessageData(messageData: any) {
        // C·∫≠p nh·∫≠t inventory v√† eligible fish
        messageData.inventory = await BattleFishInventoryService.getBattleFishInventory(
            messageData.userId, 
            messageData.guildId
        );
        messageData.eligibleFish = await BattleFishInventoryService.getEligibleBattleFish(
            messageData.userId, 
            messageData.guildId
        );
    }

    private static async refreshUI(interaction: ButtonInteraction | StringSelectMenuInteraction, messageData: any) {
        const ui = new BattleFishUI(
            messageData.inventory,
            messageData.eligibleFish,
            messageData.userId,
            messageData.guildId,
            messageData.selectedFishId
        );

        const embed = ui.createEmbed();
        const components = ui.createComponents();

        await interaction.message.edit({
            embeds: [embed],
            components: components
        });
    }

    private static calculatePower(fish: any): number {
        const stats = fish.stats || {};
        const basePower = (stats.strength || 0) + (stats.agility || 0) + (stats.intelligence || 0) + (stats.defense || 0) + (stats.luck || 0);
        return Math.floor(basePower * (1 + fish.level * 0.1));
    }

    // L∆∞u message data v√†o cache
    static setMessageData(messageId: string, data: any) {
        console.log(`üîç [DEBUG] setMessageData called:`);
        console.log(`  - messageId: ${messageId}`);
        console.log(`  - userId: ${data.userId}`);
        console.log(`  - guildId: ${data.guildId}`);
        console.log(`  - inventory items: ${data.inventory?.items?.length || 0}`);
        console.log(`  - eligibleFish: ${data.eligibleFish?.length || 0}`);
        console.log(`  - Cache size before: ${this.battleFishMessages.size}`);
        
        this.battleFishMessages.set(messageId, data);
        
        console.log(`  - Cache size after: ${this.battleFishMessages.size}`);
        console.log(`  - Available keys: ${Array.from(this.battleFishMessages.keys()).join(', ')}`);
    }

    // X√≥a message data kh·ªèi cache
    static removeMessageData(messageId: string) {
        this.battleFishMessages.delete(messageId);
    }
} 